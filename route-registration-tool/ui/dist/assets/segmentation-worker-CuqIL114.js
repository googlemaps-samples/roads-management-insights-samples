var t=6371008.8,e={centimeters:637100880,centimetres:637100880,degrees:360/(2*Math.PI),feet:20902260.511392,inches:39.37*t,kilometers:6371.0088,kilometres:6371.0088,meters:t,metres:t,miles:3958.761333810546,millimeters:6371008800,millimetres:6371008800,nauticalmiles:t/1852,radians:1,yards:6967335.223679999};function n(t,e,n={}){const r={type:"Feature"};return(0===n.id||n.id)&&(r.id=n.id),n.bbox&&(r.bbox=n.bbox),r.properties=e||{},r.geometry=t,r}function r(t,e,r={}){if(!t)throw new Error("coordinates is required");if(!Array.isArray(t))throw new Error("coordinates must be an Array");if(t.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!s(t[0])||!s(t[1]))throw new Error("coordinates must contain numbers");return n({type:"Point",coordinates:t},e,r)}function o(t){return 180*(t%(2*Math.PI))/Math.PI}function i(t){return t%360*Math.PI/180}function s(t){return!isNaN(t)&&null!==t&&!Array.isArray(t)}function a(t){if(!t)throw new Error("coord is required");if(!Array.isArray(t)){if("Feature"===t.type&&null!==t.geometry&&"Point"===t.geometry.type)return[...t.geometry.coordinates];if("Point"===t.type)return[...t.coordinates]}if(Array.isArray(t)&&t.length>=2&&!Array.isArray(t[0])&&!Array.isArray(t[1]))return[...t];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function h(t,e,n={}){if(!0===n.final)return function(t,e){let n=h(e,t);return n=(n+180)%360,n}(t,e);const r=a(t),s=a(e),c=i(r[0]),l=i(s[0]),u=i(r[1]),g=i(s[1]),d=Math.sin(l-c)*Math.cos(g),f=Math.cos(u)*Math.sin(g)-Math.sin(u)*Math.cos(g)*Math.cos(l-c);return o(Math.atan2(d,f))}function c(t,n,s,h={}){const c=a(t),l=i(c[0]),u=i(c[1]),g=i(s),d=function(t,n="kilometers"){const r=e[n];if(!r)throw new Error(n+" units is invalid");return t/r}(n,h.units),f=Math.asin(Math.sin(u)*Math.cos(d)+Math.cos(u)*Math.sin(d)*Math.cos(g)),m=o(l+Math.atan2(Math.sin(g)*Math.sin(d)*Math.cos(u),Math.cos(d)-Math.sin(u)*Math.sin(f))),p=o(f);return void 0!==c[2]?r([m,p,c[2]],h.properties):r([m,p],h.properties)}function l(t,n,r={}){var o=a(t),s=a(n),h=i(s[1]-o[1]),c=i(s[0]-o[0]),l=i(o[1]),u=i(s[1]),g=Math.pow(Math.sin(h/2),2)+Math.pow(Math.sin(c/2),2)*Math.cos(l)*Math.cos(u);return function(t,n="kilometers"){const r=e[n];if(!r)throw new Error(n+" units is invalid");return t*r}(2*Math.atan2(Math.sqrt(g),Math.sqrt(1-g)),r.units)}function u(t,e,n={}){var o;const i=("Feature"===(o=t).type?o.geometry:o).coordinates;let s=0;for(let a=0;a<i.length&&!(e>=s&&a===i.length-1);a++){if(s>=e){const t=e-s;if(t){const e=h(i[a],i[a-1])-180;return c(i[a],t,e,n)}return r(i[a])}s+=l(i[a],i[a+1],n)}return r(i[i.length-1])}function g(t){if(!t)return{type:"LineString",coordinates:[]};try{try{const e=JSON.parse(t);if(Array.isArray(e)&&e.length>0&&Array.isArray(e[0])&&2===e[0].length){const t=e[0],n=t[0],r=t[1],o=Math.abs(n)<=90&&Math.abs(r)<=180,i=Math.abs(n)<=180&&Math.abs(r)<=90;if(o&&!i){return{type:"LineString",coordinates:e.map(t=>[t[1],t[0]])}}return{type:"LineString",coordinates:e}}}catch{}const e=function(t,e){void 0===e&&(e=5);for(var n=Math.pow(10,e),r=t.length,o=new Array(Math.floor(t.length/2)),i=0,s=0,a=0,h=0;i<r;++h){var c=1,l=0,u=void 0;do{c+=(u=t.charCodeAt(i++)-63-1)<<l,l+=5}while(u>=31);s+=1&c?~(c>>1):c>>1,c=1,l=0;do{c+=(u=t.charCodeAt(i++)-63-1)<<l,l+=5}while(u>=31);a+=1&c?~(c>>1):c>>1,o[h]=[s/n,a/n]}return o.length=h,o}(t);if(0===e.length)return{type:"LineString",coordinates:[]};return{type:"LineString",coordinates:e.map(t=>{const[e,n]=t;return Math.abs(e)>90||Math.abs(n),[n,e]})}}catch(e){return{type:"LineString",coordinates:[]}}}function d(t){const e=[0];for(let n=0;n<t.length-1;n++){const o=t[n],i=t[n+1],s=l(r([o[0],o[1]]),r([i[0],i[1]]),"kilometers");e.push(e[n]+s)}return e}function f(t,e){for(let n=0;n<t.length-1;n++)if(e>=t[n]&&e<=t[n+1])return n+1;return t.length-1}function m(t,e){const r=function(t,e,r={}){if(t.length<2)throw new Error("coordinates must be an array of two or more positions");return n({type:"LineString",coordinates:t},e,r)}(t.map(t=>[t[0],t[1]])),o=d(t),i=o[o.length-1],s=[];let a=e;for(;a<i;){const n=u(r,a,{units:"kilometers"}).geometry.coordinates,i=f(o,a),h=Math.min(i,t.length-1);s.push({index:h,coordinate:n,distanceAlongRoute:a}),a+=e}return s}function p(t,e,n,r,o){const i=d(t),s=[],a=n>=i[i.length-1];let h=0,c=t.length-1;if(e>0)for(let u=0;u<i.length-1;u++){if(i[u]<=e&&i[u+1]>=e){h=u;break}if(i[u]>=e){h=u;break}}else h=0;if(a)c=t.length-1;else for(let u=0;u<i.length-1;u++){if(i[u]<=n&&i[u+1]>=n){c=u+1;break}if(i[u]>=n){c=u;break}}h=Math.max(0,Math.min(h,t.length-1)),c=Math.max(h,Math.min(c,t.length-1));if(r&&o&&(h===c||c===h+1&&i[h]<e&&i[c]>n)&&r&&o)s.push(r),r[0]===o[0]&&r[1]===o[1]||s.push(o);else{if(r)s.push(r);else if(0===e&&t.length>0){const e=t[0];(!o||Math.abs(e[0]-o[0])>=1e-10||Math.abs(e[1]-o[1])>=1e-10)&&s.push(e),h=Math.max(1,h)}for(let a=h;a<=c;a++){const h=t[a],c=i[a];if(c<e||c>n)continue;const l=r&&Math.abs(h[0]-r[0])<1e-10&&Math.abs(h[1]-r[1])<1e-10,u=o&&Math.abs(h[0]-o[0])<1e-10&&Math.abs(h[1]-o[1])<1e-10;l||u||s.push(h)}if(o){const t=s[s.length-1];t&&t[0]===o[0]&&t[1]===o[1]||s.push(o)}else if(a&&t.length>0){const e=t[t.length-1],n=s[s.length-1];n&&n[0]===e[0]&&n[1]===e[1]||s.push(e)}}const l=[];for(let u=0;u<s.length;u++)0!==u&&s[u][0]===s[u-1][0]&&s[u][1]===s[u-1][1]||l.push(s[u]);return l.length>=2?l:s}self.onmessage=t=>{if("CALCULATE_SEGMENTS"!==t.data.type)return;const{encodedPolyline:e,distanceKm:n,routeId:r,requestId:o}=t.data.payload;try{const t=g(e);if(!t.coordinates||0===t.coordinates.length)throw new Error("Invalid route coordinates");const i=t.coordinates,s=d(i),a=s[s.length-1],h=m(i,n);if(0===h.length){const t=[{id:"temp-segment-0",routeId:r,name:"Segment 1",linestringGeoJson:{type:"LineString",coordinates:i},segmentOrder:1,distanceKm:a,createdAt:(new Date).toISOString()}];return void self.postMessage({type:"SEGMENTS_CHUNK",payload:{segments:t,isComplete:!0,totalCount:1,requestId:o}})}const c=[],l=h[0],u=0,f=l.distanceAlongRoute||0,M=p(i,u,f,void 0,l.coordinate);if(M.length>=2){const t={id:"temp-segment-0",routeId:r,name:"Segment 1",linestringGeoJson:{type:"LineString",coordinates:M},segmentOrder:1,distanceKm:f-u,createdAt:(new Date).toISOString()};c.push(t)}for(let e=1;e<h.length;e++){const t=h[e-1],n=h[e],o=t.distanceAlongRoute||0,s=n.distanceAlongRoute||a,l=p(i,o,s,t.coordinate,n.coordinate);if(l.length>=2){const t=s-o;c.push({id:`temp-segment-${e}`,routeId:r,name:`Segment ${e+1}`,linestringGeoJson:{type:"LineString",coordinates:l},segmentOrder:e+1,distanceKm:t,createdAt:(new Date).toISOString()})}}const y=h[h.length-1],w=y.distanceAlongRoute||0,A=a,b=p(i,w,A,y.coordinate,void 0);if(b.length>0&&i.length>0){const t=b[b.length-1],e=i[i.length-1];(Math.abs(t[0]-e[0])>1e-10||Math.abs(t[1]-e[1])>1e-10)&&b.push(e)}if(b.length>=2){const t=A-w;c.push({id:`temp-segment-${c.length}`,routeId:r,name:`Segment ${c.length+1}`,linestringGeoJson:{type:"LineString",coordinates:b},segmentOrder:c.length+1,distanceKm:t,createdAt:(new Date).toISOString()})}self.postMessage({type:"SEGMENTS_CHUNK",payload:{segments:c,isComplete:!0,totalCount:c.length,requestId:o}})}catch(i){self.postMessage({type:"ERROR",payload:{error:i instanceof Error?i.message:"Unknown error",requestId:o}})}};
